// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bridge_msgs/perception_msgs/obstacle.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bridge_5fmsgs_2fperception_5fmsgs_2fobstacle_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bridge_5fmsgs_2fperception_5fmsgs_2fobstacle_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "bridge_msgs/basic_msgs/header.pb.h"
#include "bridge_msgs/basic_msgs/geometry.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bridge_5fmsgs_2fperception_5fmsgs_2fobstacle_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bridge_5fmsgs_2fperception_5fmsgs_2fobstacle_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bridge_5fmsgs_2fperception_5fmsgs_2fobstacle_2eproto;
namespace prescan {
namespace perception {
class Obstacle;
struct ObstacleDefaultTypeInternal;
extern ObstacleDefaultTypeInternal _Obstacle_default_instance_;
class Obstacles;
struct ObstaclesDefaultTypeInternal;
extern ObstaclesDefaultTypeInternal _Obstacles_default_instance_;
class PointLane;
struct PointLaneDefaultTypeInternal;
extern PointLaneDefaultTypeInternal _PointLane_default_instance_;
class PointLanes;
struct PointLanesDefaultTypeInternal;
extern PointLanesDefaultTypeInternal _PointLanes_default_instance_;
class PolyLane;
struct PolyLaneDefaultTypeInternal;
extern PolyLaneDefaultTypeInternal _PolyLane_default_instance_;
class PolyLanes;
struct PolyLanesDefaultTypeInternal;
extern PolyLanesDefaultTypeInternal _PolyLanes_default_instance_;
class PolyNomial;
struct PolyNomialDefaultTypeInternal;
extern PolyNomialDefaultTypeInternal _PolyNomial_default_instance_;
}  // namespace perception
}  // namespace prescan
PROTOBUF_NAMESPACE_OPEN
template<> ::prescan::perception::Obstacle* Arena::CreateMaybeMessage<::prescan::perception::Obstacle>(Arena*);
template<> ::prescan::perception::Obstacles* Arena::CreateMaybeMessage<::prescan::perception::Obstacles>(Arena*);
template<> ::prescan::perception::PointLane* Arena::CreateMaybeMessage<::prescan::perception::PointLane>(Arena*);
template<> ::prescan::perception::PointLanes* Arena::CreateMaybeMessage<::prescan::perception::PointLanes>(Arena*);
template<> ::prescan::perception::PolyLane* Arena::CreateMaybeMessage<::prescan::perception::PolyLane>(Arena*);
template<> ::prescan::perception::PolyLanes* Arena::CreateMaybeMessage<::prescan::perception::PolyLanes>(Arena*);
template<> ::prescan::perception::PolyNomial* Arena::CreateMaybeMessage<::prescan::perception::PolyNomial>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace prescan {
namespace perception {

enum Obstacle_Type : int {
  Obstacle_Type_UNKNOWN = 0,
  Obstacle_Type_UNKNOWN_MOVABLE = 1,
  Obstacle_Type_UNKNOWN_UNMOVABLE = 2,
  Obstacle_Type_PEDESTRIAN = 3,
  Obstacle_Type_BICYCLE = 4,
  Obstacle_Type_VEHICLE = 5
};
bool Obstacle_Type_IsValid(int value);
constexpr Obstacle_Type Obstacle_Type_Type_MIN = Obstacle_Type_UNKNOWN;
constexpr Obstacle_Type Obstacle_Type_Type_MAX = Obstacle_Type_VEHICLE;
constexpr int Obstacle_Type_Type_ARRAYSIZE = Obstacle_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Obstacle_Type_descriptor();
template<typename T>
inline const std::string& Obstacle_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Obstacle_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Obstacle_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Obstacle_Type_descriptor(), enum_t_value);
}
inline bool Obstacle_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Obstacle_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Obstacle_Type>(
    Obstacle_Type_descriptor(), name, value);
}
enum Obstacle_SubType : int {
  Obstacle_SubType_ST_UNKNOWN = 0,
  Obstacle_SubType_ST_UNKNOWN_MOVABLE = 1,
  Obstacle_SubType_ST_UNKNOWN_UNMOVABLE = 2,
  Obstacle_SubType_ST_CAR = 3,
  Obstacle_SubType_ST_VAN = 4,
  Obstacle_SubType_ST_TRUCK = 5,
  Obstacle_SubType_ST_BUS = 6,
  Obstacle_SubType_ST_CYCLIST = 7,
  Obstacle_SubType_ST_MOTORCYCLIST = 8,
  Obstacle_SubType_ST_TRICYCLIST = 9,
  Obstacle_SubType_ST_PEDESTRIAN = 10,
  Obstacle_SubType_ST_TRAFFICCONE = 11
};
bool Obstacle_SubType_IsValid(int value);
constexpr Obstacle_SubType Obstacle_SubType_SubType_MIN = Obstacle_SubType_ST_UNKNOWN;
constexpr Obstacle_SubType Obstacle_SubType_SubType_MAX = Obstacle_SubType_ST_TRAFFICCONE;
constexpr int Obstacle_SubType_SubType_ARRAYSIZE = Obstacle_SubType_SubType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Obstacle_SubType_descriptor();
template<typename T>
inline const std::string& Obstacle_SubType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Obstacle_SubType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Obstacle_SubType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Obstacle_SubType_descriptor(), enum_t_value);
}
inline bool Obstacle_SubType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Obstacle_SubType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Obstacle_SubType>(
    Obstacle_SubType_descriptor(), name, value);
}
enum PolyLane_Type : int {
  PolyLane_Type_Solid = 0,
  PolyLane_Type_Dash = 1,
  PolyLane_Type_SolidSolid = 2,
  PolyLane_Type_SolidDash = 3,
  PolyLane_Type_DashDash = 4,
  PolyLane_Type_DashSolid = 5
};
bool PolyLane_Type_IsValid(int value);
constexpr PolyLane_Type PolyLane_Type_Type_MIN = PolyLane_Type_Solid;
constexpr PolyLane_Type PolyLane_Type_Type_MAX = PolyLane_Type_DashSolid;
constexpr int PolyLane_Type_Type_ARRAYSIZE = PolyLane_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PolyLane_Type_descriptor();
template<typename T>
inline const std::string& PolyLane_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PolyLane_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PolyLane_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PolyLane_Type_descriptor(), enum_t_value);
}
inline bool PolyLane_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PolyLane_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PolyLane_Type>(
    PolyLane_Type_descriptor(), name, value);
}
// ===================================================================

class Obstacle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:prescan.perception.Obstacle) */ {
 public:
  inline Obstacle() : Obstacle(nullptr) {}
  ~Obstacle() override;
  explicit constexpr Obstacle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Obstacle(const Obstacle& from);
  Obstacle(Obstacle&& from) noexcept
    : Obstacle() {
    *this = ::std::move(from);
  }

  inline Obstacle& operator=(const Obstacle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Obstacle& operator=(Obstacle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Obstacle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Obstacle* internal_default_instance() {
    return reinterpret_cast<const Obstacle*>(
               &_Obstacle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Obstacle& a, Obstacle& b) {
    a.Swap(&b);
  }
  inline void Swap(Obstacle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Obstacle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Obstacle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Obstacle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Obstacle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Obstacle& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Obstacle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "prescan.perception.Obstacle";
  }
  protected:
  explicit Obstacle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Obstacle_Type Type;
  static constexpr Type UNKNOWN =
    Obstacle_Type_UNKNOWN;
  static constexpr Type UNKNOWN_MOVABLE =
    Obstacle_Type_UNKNOWN_MOVABLE;
  static constexpr Type UNKNOWN_UNMOVABLE =
    Obstacle_Type_UNKNOWN_UNMOVABLE;
  static constexpr Type PEDESTRIAN =
    Obstacle_Type_PEDESTRIAN;
  static constexpr Type BICYCLE =
    Obstacle_Type_BICYCLE;
  static constexpr Type VEHICLE =
    Obstacle_Type_VEHICLE;
  static inline bool Type_IsValid(int value) {
    return Obstacle_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Obstacle_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Obstacle_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Obstacle_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Obstacle_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Obstacle_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Obstacle_Type_Parse(name, value);
  }

  typedef Obstacle_SubType SubType;
  static constexpr SubType ST_UNKNOWN =
    Obstacle_SubType_ST_UNKNOWN;
  static constexpr SubType ST_UNKNOWN_MOVABLE =
    Obstacle_SubType_ST_UNKNOWN_MOVABLE;
  static constexpr SubType ST_UNKNOWN_UNMOVABLE =
    Obstacle_SubType_ST_UNKNOWN_UNMOVABLE;
  static constexpr SubType ST_CAR =
    Obstacle_SubType_ST_CAR;
  static constexpr SubType ST_VAN =
    Obstacle_SubType_ST_VAN;
  static constexpr SubType ST_TRUCK =
    Obstacle_SubType_ST_TRUCK;
  static constexpr SubType ST_BUS =
    Obstacle_SubType_ST_BUS;
  static constexpr SubType ST_CYCLIST =
    Obstacle_SubType_ST_CYCLIST;
  static constexpr SubType ST_MOTORCYCLIST =
    Obstacle_SubType_ST_MOTORCYCLIST;
  static constexpr SubType ST_TRICYCLIST =
    Obstacle_SubType_ST_TRICYCLIST;
  static constexpr SubType ST_PEDESTRIAN =
    Obstacle_SubType_ST_PEDESTRIAN;
  static constexpr SubType ST_TRAFFICCONE =
    Obstacle_SubType_ST_TRAFFICCONE;
  static inline bool SubType_IsValid(int value) {
    return Obstacle_SubType_IsValid(value);
  }
  static constexpr SubType SubType_MIN =
    Obstacle_SubType_SubType_MIN;
  static constexpr SubType SubType_MAX =
    Obstacle_SubType_SubType_MAX;
  static constexpr int SubType_ARRAYSIZE =
    Obstacle_SubType_SubType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SubType_descriptor() {
    return Obstacle_SubType_descriptor();
  }
  template<typename T>
  static inline const std::string& SubType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SubType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SubType_Name.");
    return Obstacle_SubType_Name(enum_t_value);
  }
  static inline bool SubType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SubType* value) {
    return Obstacle_SubType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 2,
    kVelocityFieldNumber = 4,
    kBoxFieldNumber = 5,
    kHeaderFieldNumber = 20,
    kHeadingFieldNumber = 3,
    kIdFieldNumber = 1,
    kTypeFieldNumber = 10,
    kSubTypeFieldNumber = 19,
    kConfidenceFieldNumber = 13,
  };
  // optional .prescan.common.Point3D position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::prescan::common::Point3D& position() const;
  PROTOBUF_NODISCARD ::prescan::common::Point3D* release_position();
  ::prescan::common::Point3D* mutable_position();
  void set_allocated_position(::prescan::common::Point3D* position);
  private:
  const ::prescan::common::Point3D& _internal_position() const;
  ::prescan::common::Point3D* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::prescan::common::Point3D* position);
  ::prescan::common::Point3D* unsafe_arena_release_position();

  // optional .prescan.common.Point3D velocity = 4;
  bool has_velocity() const;
  private:
  bool _internal_has_velocity() const;
  public:
  void clear_velocity();
  const ::prescan::common::Point3D& velocity() const;
  PROTOBUF_NODISCARD ::prescan::common::Point3D* release_velocity();
  ::prescan::common::Point3D* mutable_velocity();
  void set_allocated_velocity(::prescan::common::Point3D* velocity);
  private:
  const ::prescan::common::Point3D& _internal_velocity() const;
  ::prescan::common::Point3D* _internal_mutable_velocity();
  public:
  void unsafe_arena_set_allocated_velocity(
      ::prescan::common::Point3D* velocity);
  ::prescan::common::Point3D* unsafe_arena_release_velocity();

  // optional .prescan.common.BoundingBox3D box = 5;
  bool has_box() const;
  private:
  bool _internal_has_box() const;
  public:
  void clear_box();
  const ::prescan::common::BoundingBox3D& box() const;
  PROTOBUF_NODISCARD ::prescan::common::BoundingBox3D* release_box();
  ::prescan::common::BoundingBox3D* mutable_box();
  void set_allocated_box(::prescan::common::BoundingBox3D* box);
  private:
  const ::prescan::common::BoundingBox3D& _internal_box() const;
  ::prescan::common::BoundingBox3D* _internal_mutable_box();
  public:
  void unsafe_arena_set_allocated_box(
      ::prescan::common::BoundingBox3D* box);
  ::prescan::common::BoundingBox3D* unsafe_arena_release_box();

  // optional .prescan.common.Header header = 20;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::prescan::common::Header& header() const;
  PROTOBUF_NODISCARD ::prescan::common::Header* release_header();
  ::prescan::common::Header* mutable_header();
  void set_allocated_header(::prescan::common::Header* header);
  private:
  const ::prescan::common::Header& _internal_header() const;
  ::prescan::common::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::prescan::common::Header* header);
  ::prescan::common::Header* unsafe_arena_release_header();

  // optional double heading = 3;
  bool has_heading() const;
  private:
  bool _internal_has_heading() const;
  public:
  void clear_heading();
  double heading() const;
  void set_heading(double value);
  private:
  double _internal_heading() const;
  void _internal_set_heading(double value);
  public:

  // optional int32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // optional .prescan.perception.Obstacle.Type type = 10;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::prescan::perception::Obstacle_Type type() const;
  void set_type(::prescan::perception::Obstacle_Type value);
  private:
  ::prescan::perception::Obstacle_Type _internal_type() const;
  void _internal_set_type(::prescan::perception::Obstacle_Type value);
  public:

  // optional .prescan.perception.Obstacle.SubType sub_type = 19;
  bool has_sub_type() const;
  private:
  bool _internal_has_sub_type() const;
  public:
  void clear_sub_type();
  ::prescan::perception::Obstacle_SubType sub_type() const;
  void set_sub_type(::prescan::perception::Obstacle_SubType value);
  private:
  ::prescan::perception::Obstacle_SubType _internal_sub_type() const;
  void _internal_set_sub_type(::prescan::perception::Obstacle_SubType value);
  public:

  // optional double confidence = 13 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_confidence() const;
  private:
  bool _internal_has_confidence() const;
  public:
  PROTOBUF_DEPRECATED void clear_confidence();
  PROTOBUF_DEPRECATED double confidence() const;
  PROTOBUF_DEPRECATED void set_confidence(double value);
  private:
  double _internal_confidence() const;
  void _internal_set_confidence(double value);
  public:

  // @@protoc_insertion_point(class_scope:prescan.perception.Obstacle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::prescan::common::Point3D* position_;
  ::prescan::common::Point3D* velocity_;
  ::prescan::common::BoundingBox3D* box_;
  ::prescan::common::Header* header_;
  double heading_;
  int32_t id_;
  int type_;
  int sub_type_;
  double confidence_;
  friend struct ::TableStruct_bridge_5fmsgs_2fperception_5fmsgs_2fobstacle_2eproto;
};
// -------------------------------------------------------------------

class PointLane final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:prescan.perception.PointLane) */ {
 public:
  inline PointLane() : PointLane(nullptr) {}
  ~PointLane() override;
  explicit constexpr PointLane(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PointLane(const PointLane& from);
  PointLane(PointLane&& from) noexcept
    : PointLane() {
    *this = ::std::move(from);
  }

  inline PointLane& operator=(const PointLane& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointLane& operator=(PointLane&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointLane& default_instance() {
    return *internal_default_instance();
  }
  static inline const PointLane* internal_default_instance() {
    return reinterpret_cast<const PointLane*>(
               &_PointLane_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PointLane& a, PointLane& b) {
    a.Swap(&b);
  }
  inline void Swap(PointLane* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointLane* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointLane* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PointLane>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PointLane& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PointLane& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PointLane* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "prescan.perception.PointLane";
  }
  protected:
  explicit PointLane(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointFieldNumber = 1,
    kHeaderFieldNumber = 3,
    kNumericIDFieldNumber = 2,
  };
  // repeated .prescan.common.Point3D point = 1;
  int point_size() const;
  private:
  int _internal_point_size() const;
  public:
  void clear_point();
  ::prescan::common::Point3D* mutable_point(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::prescan::common::Point3D >*
      mutable_point();
  private:
  const ::prescan::common::Point3D& _internal_point(int index) const;
  ::prescan::common::Point3D* _internal_add_point();
  public:
  const ::prescan::common::Point3D& point(int index) const;
  ::prescan::common::Point3D* add_point();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::prescan::common::Point3D >&
      point() const;

  // optional .prescan.common.Header header = 3;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::prescan::common::Header& header() const;
  PROTOBUF_NODISCARD ::prescan::common::Header* release_header();
  ::prescan::common::Header* mutable_header();
  void set_allocated_header(::prescan::common::Header* header);
  private:
  const ::prescan::common::Header& _internal_header() const;
  ::prescan::common::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::prescan::common::Header* header);
  ::prescan::common::Header* unsafe_arena_release_header();

  // optional uint32 numericID = 2;
  bool has_numericid() const;
  private:
  bool _internal_has_numericid() const;
  public:
  void clear_numericid();
  uint32_t numericid() const;
  void set_numericid(uint32_t value);
  private:
  uint32_t _internal_numericid() const;
  void _internal_set_numericid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:prescan.perception.PointLane)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::prescan::common::Point3D > point_;
  ::prescan::common::Header* header_;
  uint32_t numericid_;
  friend struct ::TableStruct_bridge_5fmsgs_2fperception_5fmsgs_2fobstacle_2eproto;
};
// -------------------------------------------------------------------

class PointLanes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:prescan.perception.PointLanes) */ {
 public:
  inline PointLanes() : PointLanes(nullptr) {}
  ~PointLanes() override;
  explicit constexpr PointLanes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PointLanes(const PointLanes& from);
  PointLanes(PointLanes&& from) noexcept
    : PointLanes() {
    *this = ::std::move(from);
  }

  inline PointLanes& operator=(const PointLanes& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointLanes& operator=(PointLanes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointLanes& default_instance() {
    return *internal_default_instance();
  }
  static inline const PointLanes* internal_default_instance() {
    return reinterpret_cast<const PointLanes*>(
               &_PointLanes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PointLanes& a, PointLanes& b) {
    a.Swap(&b);
  }
  inline void Swap(PointLanes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointLanes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointLanes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PointLanes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PointLanes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PointLanes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PointLanes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "prescan.perception.PointLanes";
  }
  protected:
  explicit PointLanes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLaneFieldNumber = 1,
    kHeaderFieldNumber = 2,
  };
  // repeated .prescan.perception.PointLane lane = 1;
  int lane_size() const;
  private:
  int _internal_lane_size() const;
  public:
  void clear_lane();
  ::prescan::perception::PointLane* mutable_lane(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::prescan::perception::PointLane >*
      mutable_lane();
  private:
  const ::prescan::perception::PointLane& _internal_lane(int index) const;
  ::prescan::perception::PointLane* _internal_add_lane();
  public:
  const ::prescan::perception::PointLane& lane(int index) const;
  ::prescan::perception::PointLane* add_lane();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::prescan::perception::PointLane >&
      lane() const;

  // optional .prescan.common.Header header = 2;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::prescan::common::Header& header() const;
  PROTOBUF_NODISCARD ::prescan::common::Header* release_header();
  ::prescan::common::Header* mutable_header();
  void set_allocated_header(::prescan::common::Header* header);
  private:
  const ::prescan::common::Header& _internal_header() const;
  ::prescan::common::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::prescan::common::Header* header);
  ::prescan::common::Header* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:prescan.perception.PointLanes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::prescan::perception::PointLane > lane_;
  ::prescan::common::Header* header_;
  friend struct ::TableStruct_bridge_5fmsgs_2fperception_5fmsgs_2fobstacle_2eproto;
};
// -------------------------------------------------------------------

class PolyNomial final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:prescan.perception.PolyNomial) */ {
 public:
  inline PolyNomial() : PolyNomial(nullptr) {}
  ~PolyNomial() override;
  explicit constexpr PolyNomial(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PolyNomial(const PolyNomial& from);
  PolyNomial(PolyNomial&& from) noexcept
    : PolyNomial() {
    *this = ::std::move(from);
  }

  inline PolyNomial& operator=(const PolyNomial& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolyNomial& operator=(PolyNomial&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PolyNomial& default_instance() {
    return *internal_default_instance();
  }
  static inline const PolyNomial* internal_default_instance() {
    return reinterpret_cast<const PolyNomial*>(
               &_PolyNomial_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PolyNomial& a, PolyNomial& b) {
    a.Swap(&b);
  }
  inline void Swap(PolyNomial* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolyNomial* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PolyNomial* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PolyNomial>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PolyNomial& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PolyNomial& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PolyNomial* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "prescan.perception.PolyNomial";
  }
  protected:
  explicit PolyNomial(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kN0FieldNumber = 1,
    kN1FieldNumber = 2,
    kN2FieldNumber = 3,
    kN3FieldNumber = 4,
  };
  // optional double N0 = 1;
  bool has_n0() const;
  private:
  bool _internal_has_n0() const;
  public:
  void clear_n0();
  double n0() const;
  void set_n0(double value);
  private:
  double _internal_n0() const;
  void _internal_set_n0(double value);
  public:

  // optional double N1 = 2;
  bool has_n1() const;
  private:
  bool _internal_has_n1() const;
  public:
  void clear_n1();
  double n1() const;
  void set_n1(double value);
  private:
  double _internal_n1() const;
  void _internal_set_n1(double value);
  public:

  // optional double N2 = 3;
  bool has_n2() const;
  private:
  bool _internal_has_n2() const;
  public:
  void clear_n2();
  double n2() const;
  void set_n2(double value);
  private:
  double _internal_n2() const;
  void _internal_set_n2(double value);
  public:

  // optional double N3 = 4;
  bool has_n3() const;
  private:
  bool _internal_has_n3() const;
  public:
  void clear_n3();
  double n3() const;
  void set_n3(double value);
  private:
  double _internal_n3() const;
  void _internal_set_n3(double value);
  public:

  // @@protoc_insertion_point(class_scope:prescan.perception.PolyNomial)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double n0_;
  double n1_;
  double n2_;
  double n3_;
  friend struct ::TableStruct_bridge_5fmsgs_2fperception_5fmsgs_2fobstacle_2eproto;
};
// -------------------------------------------------------------------

class PolyLane final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:prescan.perception.PolyLane) */ {
 public:
  inline PolyLane() : PolyLane(nullptr) {}
  ~PolyLane() override;
  explicit constexpr PolyLane(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PolyLane(const PolyLane& from);
  PolyLane(PolyLane&& from) noexcept
    : PolyLane() {
    *this = ::std::move(from);
  }

  inline PolyLane& operator=(const PolyLane& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolyLane& operator=(PolyLane&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PolyLane& default_instance() {
    return *internal_default_instance();
  }
  static inline const PolyLane* internal_default_instance() {
    return reinterpret_cast<const PolyLane*>(
               &_PolyLane_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PolyLane& a, PolyLane& b) {
    a.Swap(&b);
  }
  inline void Swap(PolyLane* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolyLane* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PolyLane* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PolyLane>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PolyLane& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PolyLane& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PolyLane* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "prescan.perception.PolyLane";
  }
  protected:
  explicit PolyLane(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PolyLane_Type Type;
  static constexpr Type Solid =
    PolyLane_Type_Solid;
  static constexpr Type Dash =
    PolyLane_Type_Dash;
  static constexpr Type SolidSolid =
    PolyLane_Type_SolidSolid;
  static constexpr Type SolidDash =
    PolyLane_Type_SolidDash;
  static constexpr Type DashDash =
    PolyLane_Type_DashDash;
  static constexpr Type DashSolid =
    PolyLane_Type_DashSolid;
  static inline bool Type_IsValid(int value) {
    return PolyLane_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    PolyLane_Type_Type_MIN;
  static constexpr Type Type_MAX =
    PolyLane_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    PolyLane_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return PolyLane_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return PolyLane_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return PolyLane_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 4,
    kYFieldNumber = 5,
    kZFieldNumber = 6,
    kHeaderFieldNumber = 12,
    kQualityFieldNumber = 2,
    kTypeFieldNumber = 1,
    kModelDegreeFieldNumber = 3,
    kLengthFieldNumber = 8,
    kGroupIDFieldNumber = 9,
    kLaneLabelFieldNumber = 10,
    kNumericIDFieldNumber = 11,
  };
  // optional .prescan.perception.PolyNomial X = 4;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  const ::prescan::perception::PolyNomial& x() const;
  PROTOBUF_NODISCARD ::prescan::perception::PolyNomial* release_x();
  ::prescan::perception::PolyNomial* mutable_x();
  void set_allocated_x(::prescan::perception::PolyNomial* x);
  private:
  const ::prescan::perception::PolyNomial& _internal_x() const;
  ::prescan::perception::PolyNomial* _internal_mutable_x();
  public:
  void unsafe_arena_set_allocated_x(
      ::prescan::perception::PolyNomial* x);
  ::prescan::perception::PolyNomial* unsafe_arena_release_x();

  // optional .prescan.perception.PolyNomial Y = 5;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  const ::prescan::perception::PolyNomial& y() const;
  PROTOBUF_NODISCARD ::prescan::perception::PolyNomial* release_y();
  ::prescan::perception::PolyNomial* mutable_y();
  void set_allocated_y(::prescan::perception::PolyNomial* y);
  private:
  const ::prescan::perception::PolyNomial& _internal_y() const;
  ::prescan::perception::PolyNomial* _internal_mutable_y();
  public:
  void unsafe_arena_set_allocated_y(
      ::prescan::perception::PolyNomial* y);
  ::prescan::perception::PolyNomial* unsafe_arena_release_y();

  // optional .prescan.perception.PolyNomial Z = 6;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  const ::prescan::perception::PolyNomial& z() const;
  PROTOBUF_NODISCARD ::prescan::perception::PolyNomial* release_z();
  ::prescan::perception::PolyNomial* mutable_z();
  void set_allocated_z(::prescan::perception::PolyNomial* z);
  private:
  const ::prescan::perception::PolyNomial& _internal_z() const;
  ::prescan::perception::PolyNomial* _internal_mutable_z();
  public:
  void unsafe_arena_set_allocated_z(
      ::prescan::perception::PolyNomial* z);
  ::prescan::perception::PolyNomial* unsafe_arena_release_z();

  // optional .prescan.common.Header header = 12;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::prescan::common::Header& header() const;
  PROTOBUF_NODISCARD ::prescan::common::Header* release_header();
  ::prescan::common::Header* mutable_header();
  void set_allocated_header(::prescan::common::Header* header);
  private:
  const ::prescan::common::Header& _internal_header() const;
  ::prescan::common::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::prescan::common::Header* header);
  ::prescan::common::Header* unsafe_arena_release_header();

  // optional double quality = 2;
  bool has_quality() const;
  private:
  bool _internal_has_quality() const;
  public:
  void clear_quality();
  double quality() const;
  void set_quality(double value);
  private:
  double _internal_quality() const;
  void _internal_set_quality(double value);
  public:

  // optional .prescan.perception.PolyLane.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::prescan::perception::PolyLane_Type type() const;
  void set_type(::prescan::perception::PolyLane_Type value);
  private:
  ::prescan::perception::PolyLane_Type _internal_type() const;
  void _internal_set_type(::prescan::perception::PolyLane_Type value);
  public:

  // optional int32 model_degree = 3;
  bool has_model_degree() const;
  private:
  bool _internal_has_model_degree() const;
  public:
  void clear_model_degree();
  int32_t model_degree() const;
  void set_model_degree(int32_t value);
  private:
  int32_t _internal_model_degree() const;
  void _internal_set_model_degree(int32_t value);
  public:

  // optional double length = 8;
  bool has_length() const;
  private:
  bool _internal_has_length() const;
  public:
  void clear_length();
  double length() const;
  void set_length(double value);
  private:
  double _internal_length() const;
  void _internal_set_length(double value);
  public:

  // optional uint32 groupID = 9;
  bool has_groupid() const;
  private:
  bool _internal_has_groupid() const;
  public:
  void clear_groupid();
  uint32_t groupid() const;
  void set_groupid(uint32_t value);
  private:
  uint32_t _internal_groupid() const;
  void _internal_set_groupid(uint32_t value);
  public:

  // optional uint32 lane_label = 10;
  bool has_lane_label() const;
  private:
  bool _internal_has_lane_label() const;
  public:
  void clear_lane_label();
  uint32_t lane_label() const;
  void set_lane_label(uint32_t value);
  private:
  uint32_t _internal_lane_label() const;
  void _internal_set_lane_label(uint32_t value);
  public:

  // optional uint32 numericID = 11;
  bool has_numericid() const;
  private:
  bool _internal_has_numericid() const;
  public:
  void clear_numericid();
  uint32_t numericid() const;
  void set_numericid(uint32_t value);
  private:
  uint32_t _internal_numericid() const;
  void _internal_set_numericid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:prescan.perception.PolyLane)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::prescan::perception::PolyNomial* x_;
  ::prescan::perception::PolyNomial* y_;
  ::prescan::perception::PolyNomial* z_;
  ::prescan::common::Header* header_;
  double quality_;
  int type_;
  int32_t model_degree_;
  double length_;
  uint32_t groupid_;
  uint32_t lane_label_;
  uint32_t numericid_;
  friend struct ::TableStruct_bridge_5fmsgs_2fperception_5fmsgs_2fobstacle_2eproto;
};
// -------------------------------------------------------------------

class PolyLanes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:prescan.perception.PolyLanes) */ {
 public:
  inline PolyLanes() : PolyLanes(nullptr) {}
  ~PolyLanes() override;
  explicit constexpr PolyLanes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PolyLanes(const PolyLanes& from);
  PolyLanes(PolyLanes&& from) noexcept
    : PolyLanes() {
    *this = ::std::move(from);
  }

  inline PolyLanes& operator=(const PolyLanes& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolyLanes& operator=(PolyLanes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PolyLanes& default_instance() {
    return *internal_default_instance();
  }
  static inline const PolyLanes* internal_default_instance() {
    return reinterpret_cast<const PolyLanes*>(
               &_PolyLanes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PolyLanes& a, PolyLanes& b) {
    a.Swap(&b);
  }
  inline void Swap(PolyLanes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolyLanes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PolyLanes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PolyLanes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PolyLanes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PolyLanes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PolyLanes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "prescan.perception.PolyLanes";
  }
  protected:
  explicit PolyLanes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLaneFieldNumber = 1,
    kHeaderFieldNumber = 2,
  };
  // repeated .prescan.perception.PolyLane lane = 1;
  int lane_size() const;
  private:
  int _internal_lane_size() const;
  public:
  void clear_lane();
  ::prescan::perception::PolyLane* mutable_lane(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::prescan::perception::PolyLane >*
      mutable_lane();
  private:
  const ::prescan::perception::PolyLane& _internal_lane(int index) const;
  ::prescan::perception::PolyLane* _internal_add_lane();
  public:
  const ::prescan::perception::PolyLane& lane(int index) const;
  ::prescan::perception::PolyLane* add_lane();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::prescan::perception::PolyLane >&
      lane() const;

  // optional .prescan.common.Header header = 2;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::prescan::common::Header& header() const;
  PROTOBUF_NODISCARD ::prescan::common::Header* release_header();
  ::prescan::common::Header* mutable_header();
  void set_allocated_header(::prescan::common::Header* header);
  private:
  const ::prescan::common::Header& _internal_header() const;
  ::prescan::common::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::prescan::common::Header* header);
  ::prescan::common::Header* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:prescan.perception.PolyLanes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::prescan::perception::PolyLane > lane_;
  ::prescan::common::Header* header_;
  friend struct ::TableStruct_bridge_5fmsgs_2fperception_5fmsgs_2fobstacle_2eproto;
};
// -------------------------------------------------------------------

class Obstacles final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:prescan.perception.Obstacles) */ {
 public:
  inline Obstacles() : Obstacles(nullptr) {}
  ~Obstacles() override;
  explicit constexpr Obstacles(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Obstacles(const Obstacles& from);
  Obstacles(Obstacles&& from) noexcept
    : Obstacles() {
    *this = ::std::move(from);
  }

  inline Obstacles& operator=(const Obstacles& from) {
    CopyFrom(from);
    return *this;
  }
  inline Obstacles& operator=(Obstacles&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Obstacles& default_instance() {
    return *internal_default_instance();
  }
  static inline const Obstacles* internal_default_instance() {
    return reinterpret_cast<const Obstacles*>(
               &_Obstacles_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Obstacles& a, Obstacles& b) {
    a.Swap(&b);
  }
  inline void Swap(Obstacles* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Obstacles* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Obstacles* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Obstacles>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Obstacles& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Obstacles& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Obstacles* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "prescan.perception.Obstacles";
  }
  protected:
  explicit Obstacles(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPerceptionObstacleFieldNumber = 1,
    kHeaderFieldNumber = 2,
  };
  // repeated .prescan.perception.Obstacle perception_obstacle = 1;
  int perception_obstacle_size() const;
  private:
  int _internal_perception_obstacle_size() const;
  public:
  void clear_perception_obstacle();
  ::prescan::perception::Obstacle* mutable_perception_obstacle(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::prescan::perception::Obstacle >*
      mutable_perception_obstacle();
  private:
  const ::prescan::perception::Obstacle& _internal_perception_obstacle(int index) const;
  ::prescan::perception::Obstacle* _internal_add_perception_obstacle();
  public:
  const ::prescan::perception::Obstacle& perception_obstacle(int index) const;
  ::prescan::perception::Obstacle* add_perception_obstacle();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::prescan::perception::Obstacle >&
      perception_obstacle() const;

  // optional .prescan.common.Header header = 2;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::prescan::common::Header& header() const;
  PROTOBUF_NODISCARD ::prescan::common::Header* release_header();
  ::prescan::common::Header* mutable_header();
  void set_allocated_header(::prescan::common::Header* header);
  private:
  const ::prescan::common::Header& _internal_header() const;
  ::prescan::common::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::prescan::common::Header* header);
  ::prescan::common::Header* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:prescan.perception.Obstacles)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::prescan::perception::Obstacle > perception_obstacle_;
  ::prescan::common::Header* header_;
  friend struct ::TableStruct_bridge_5fmsgs_2fperception_5fmsgs_2fobstacle_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Obstacle

// optional int32 id = 1;
inline bool Obstacle::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Obstacle::has_id() const {
  return _internal_has_id();
}
inline void Obstacle::clear_id() {
  id_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t Obstacle::_internal_id() const {
  return id_;
}
inline int32_t Obstacle::id() const {
  // @@protoc_insertion_point(field_get:prescan.perception.Obstacle.id)
  return _internal_id();
}
inline void Obstacle::_internal_set_id(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  id_ = value;
}
inline void Obstacle::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:prescan.perception.Obstacle.id)
}

// optional .prescan.common.Point3D position = 2;
inline bool Obstacle::_internal_has_position() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || position_ != nullptr);
  return value;
}
inline bool Obstacle::has_position() const {
  return _internal_has_position();
}
inline const ::prescan::common::Point3D& Obstacle::_internal_position() const {
  const ::prescan::common::Point3D* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::prescan::common::Point3D&>(
      ::prescan::common::_Point3D_default_instance_);
}
inline const ::prescan::common::Point3D& Obstacle::position() const {
  // @@protoc_insertion_point(field_get:prescan.perception.Obstacle.position)
  return _internal_position();
}
inline void Obstacle::unsafe_arena_set_allocated_position(
    ::prescan::common::Point3D* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:prescan.perception.Obstacle.position)
}
inline ::prescan::common::Point3D* Obstacle::release_position() {
  _has_bits_[0] &= ~0x00000001u;
  ::prescan::common::Point3D* temp = position_;
  position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::prescan::common::Point3D* Obstacle::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:prescan.perception.Obstacle.position)
  _has_bits_[0] &= ~0x00000001u;
  ::prescan::common::Point3D* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::prescan::common::Point3D* Obstacle::_internal_mutable_position() {
  _has_bits_[0] |= 0x00000001u;
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::prescan::common::Point3D>(GetArenaForAllocation());
    position_ = p;
  }
  return position_;
}
inline ::prescan::common::Point3D* Obstacle::mutable_position() {
  ::prescan::common::Point3D* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:prescan.perception.Obstacle.position)
  return _msg;
}
inline void Obstacle::set_allocated_position(::prescan::common::Point3D* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position));
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:prescan.perception.Obstacle.position)
}

// optional double heading = 3;
inline bool Obstacle::_internal_has_heading() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Obstacle::has_heading() const {
  return _internal_has_heading();
}
inline void Obstacle::clear_heading() {
  heading_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double Obstacle::_internal_heading() const {
  return heading_;
}
inline double Obstacle::heading() const {
  // @@protoc_insertion_point(field_get:prescan.perception.Obstacle.heading)
  return _internal_heading();
}
inline void Obstacle::_internal_set_heading(double value) {
  _has_bits_[0] |= 0x00000010u;
  heading_ = value;
}
inline void Obstacle::set_heading(double value) {
  _internal_set_heading(value);
  // @@protoc_insertion_point(field_set:prescan.perception.Obstacle.heading)
}

// optional .prescan.common.Point3D velocity = 4;
inline bool Obstacle::_internal_has_velocity() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || velocity_ != nullptr);
  return value;
}
inline bool Obstacle::has_velocity() const {
  return _internal_has_velocity();
}
inline const ::prescan::common::Point3D& Obstacle::_internal_velocity() const {
  const ::prescan::common::Point3D* p = velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::prescan::common::Point3D&>(
      ::prescan::common::_Point3D_default_instance_);
}
inline const ::prescan::common::Point3D& Obstacle::velocity() const {
  // @@protoc_insertion_point(field_get:prescan.perception.Obstacle.velocity)
  return _internal_velocity();
}
inline void Obstacle::unsafe_arena_set_allocated_velocity(
    ::prescan::common::Point3D* velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity_);
  }
  velocity_ = velocity;
  if (velocity) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:prescan.perception.Obstacle.velocity)
}
inline ::prescan::common::Point3D* Obstacle::release_velocity() {
  _has_bits_[0] &= ~0x00000002u;
  ::prescan::common::Point3D* temp = velocity_;
  velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::prescan::common::Point3D* Obstacle::unsafe_arena_release_velocity() {
  // @@protoc_insertion_point(field_release:prescan.perception.Obstacle.velocity)
  _has_bits_[0] &= ~0x00000002u;
  ::prescan::common::Point3D* temp = velocity_;
  velocity_ = nullptr;
  return temp;
}
inline ::prescan::common::Point3D* Obstacle::_internal_mutable_velocity() {
  _has_bits_[0] |= 0x00000002u;
  if (velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::prescan::common::Point3D>(GetArenaForAllocation());
    velocity_ = p;
  }
  return velocity_;
}
inline ::prescan::common::Point3D* Obstacle::mutable_velocity() {
  ::prescan::common::Point3D* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:prescan.perception.Obstacle.velocity)
  return _msg;
}
inline void Obstacle::set_allocated_velocity(::prescan::common::Point3D* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity_);
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity));
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:prescan.perception.Obstacle.velocity)
}

// optional .prescan.common.BoundingBox3D box = 5;
inline bool Obstacle::_internal_has_box() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || box_ != nullptr);
  return value;
}
inline bool Obstacle::has_box() const {
  return _internal_has_box();
}
inline const ::prescan::common::BoundingBox3D& Obstacle::_internal_box() const {
  const ::prescan::common::BoundingBox3D* p = box_;
  return p != nullptr ? *p : reinterpret_cast<const ::prescan::common::BoundingBox3D&>(
      ::prescan::common::_BoundingBox3D_default_instance_);
}
inline const ::prescan::common::BoundingBox3D& Obstacle::box() const {
  // @@protoc_insertion_point(field_get:prescan.perception.Obstacle.box)
  return _internal_box();
}
inline void Obstacle::unsafe_arena_set_allocated_box(
    ::prescan::common::BoundingBox3D* box) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(box_);
  }
  box_ = box;
  if (box) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:prescan.perception.Obstacle.box)
}
inline ::prescan::common::BoundingBox3D* Obstacle::release_box() {
  _has_bits_[0] &= ~0x00000004u;
  ::prescan::common::BoundingBox3D* temp = box_;
  box_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::prescan::common::BoundingBox3D* Obstacle::unsafe_arena_release_box() {
  // @@protoc_insertion_point(field_release:prescan.perception.Obstacle.box)
  _has_bits_[0] &= ~0x00000004u;
  ::prescan::common::BoundingBox3D* temp = box_;
  box_ = nullptr;
  return temp;
}
inline ::prescan::common::BoundingBox3D* Obstacle::_internal_mutable_box() {
  _has_bits_[0] |= 0x00000004u;
  if (box_ == nullptr) {
    auto* p = CreateMaybeMessage<::prescan::common::BoundingBox3D>(GetArenaForAllocation());
    box_ = p;
  }
  return box_;
}
inline ::prescan::common::BoundingBox3D* Obstacle::mutable_box() {
  ::prescan::common::BoundingBox3D* _msg = _internal_mutable_box();
  // @@protoc_insertion_point(field_mutable:prescan.perception.Obstacle.box)
  return _msg;
}
inline void Obstacle::set_allocated_box(::prescan::common::BoundingBox3D* box) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(box_);
  }
  if (box) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(box));
    if (message_arena != submessage_arena) {
      box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, box, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  box_ = box;
  // @@protoc_insertion_point(field_set_allocated:prescan.perception.Obstacle.box)
}

// optional .prescan.perception.Obstacle.Type type = 10;
inline bool Obstacle::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Obstacle::has_type() const {
  return _internal_has_type();
}
inline void Obstacle::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::prescan::perception::Obstacle_Type Obstacle::_internal_type() const {
  return static_cast< ::prescan::perception::Obstacle_Type >(type_);
}
inline ::prescan::perception::Obstacle_Type Obstacle::type() const {
  // @@protoc_insertion_point(field_get:prescan.perception.Obstacle.type)
  return _internal_type();
}
inline void Obstacle::_internal_set_type(::prescan::perception::Obstacle_Type value) {
  assert(::prescan::perception::Obstacle_Type_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  type_ = value;
}
inline void Obstacle::set_type(::prescan::perception::Obstacle_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:prescan.perception.Obstacle.type)
}

// optional double confidence = 13 [deprecated = true];
inline bool Obstacle::_internal_has_confidence() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Obstacle::has_confidence() const {
  return _internal_has_confidence();
}
inline void Obstacle::clear_confidence() {
  confidence_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline double Obstacle::_internal_confidence() const {
  return confidence_;
}
inline double Obstacle::confidence() const {
  // @@protoc_insertion_point(field_get:prescan.perception.Obstacle.confidence)
  return _internal_confidence();
}
inline void Obstacle::_internal_set_confidence(double value) {
  _has_bits_[0] |= 0x00000100u;
  confidence_ = value;
}
inline void Obstacle::set_confidence(double value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:prescan.perception.Obstacle.confidence)
}

// optional .prescan.perception.Obstacle.SubType sub_type = 19;
inline bool Obstacle::_internal_has_sub_type() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Obstacle::has_sub_type() const {
  return _internal_has_sub_type();
}
inline void Obstacle::clear_sub_type() {
  sub_type_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::prescan::perception::Obstacle_SubType Obstacle::_internal_sub_type() const {
  return static_cast< ::prescan::perception::Obstacle_SubType >(sub_type_);
}
inline ::prescan::perception::Obstacle_SubType Obstacle::sub_type() const {
  // @@protoc_insertion_point(field_get:prescan.perception.Obstacle.sub_type)
  return _internal_sub_type();
}
inline void Obstacle::_internal_set_sub_type(::prescan::perception::Obstacle_SubType value) {
  assert(::prescan::perception::Obstacle_SubType_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  sub_type_ = value;
}
inline void Obstacle::set_sub_type(::prescan::perception::Obstacle_SubType value) {
  _internal_set_sub_type(value);
  // @@protoc_insertion_point(field_set:prescan.perception.Obstacle.sub_type)
}

// optional .prescan.common.Header header = 20;
inline bool Obstacle::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool Obstacle::has_header() const {
  return _internal_has_header();
}
inline const ::prescan::common::Header& Obstacle::_internal_header() const {
  const ::prescan::common::Header* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::prescan::common::Header&>(
      ::prescan::common::_Header_default_instance_);
}
inline const ::prescan::common::Header& Obstacle::header() const {
  // @@protoc_insertion_point(field_get:prescan.perception.Obstacle.header)
  return _internal_header();
}
inline void Obstacle::unsafe_arena_set_allocated_header(
    ::prescan::common::Header* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:prescan.perception.Obstacle.header)
}
inline ::prescan::common::Header* Obstacle::release_header() {
  _has_bits_[0] &= ~0x00000008u;
  ::prescan::common::Header* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::prescan::common::Header* Obstacle::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:prescan.perception.Obstacle.header)
  _has_bits_[0] &= ~0x00000008u;
  ::prescan::common::Header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::prescan::common::Header* Obstacle::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000008u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::prescan::common::Header>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::prescan::common::Header* Obstacle::mutable_header() {
  ::prescan::common::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:prescan.perception.Obstacle.header)
  return _msg;
}
inline void Obstacle::set_allocated_header(::prescan::common::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:prescan.perception.Obstacle.header)
}

// -------------------------------------------------------------------

// PointLane

// repeated .prescan.common.Point3D point = 1;
inline int PointLane::_internal_point_size() const {
  return point_.size();
}
inline int PointLane::point_size() const {
  return _internal_point_size();
}
inline ::prescan::common::Point3D* PointLane::mutable_point(int index) {
  // @@protoc_insertion_point(field_mutable:prescan.perception.PointLane.point)
  return point_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::prescan::common::Point3D >*
PointLane::mutable_point() {
  // @@protoc_insertion_point(field_mutable_list:prescan.perception.PointLane.point)
  return &point_;
}
inline const ::prescan::common::Point3D& PointLane::_internal_point(int index) const {
  return point_.Get(index);
}
inline const ::prescan::common::Point3D& PointLane::point(int index) const {
  // @@protoc_insertion_point(field_get:prescan.perception.PointLane.point)
  return _internal_point(index);
}
inline ::prescan::common::Point3D* PointLane::_internal_add_point() {
  return point_.Add();
}
inline ::prescan::common::Point3D* PointLane::add_point() {
  ::prescan::common::Point3D* _add = _internal_add_point();
  // @@protoc_insertion_point(field_add:prescan.perception.PointLane.point)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::prescan::common::Point3D >&
PointLane::point() const {
  // @@protoc_insertion_point(field_list:prescan.perception.PointLane.point)
  return point_;
}

// optional uint32 numericID = 2;
inline bool PointLane::_internal_has_numericid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PointLane::has_numericid() const {
  return _internal_has_numericid();
}
inline void PointLane::clear_numericid() {
  numericid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t PointLane::_internal_numericid() const {
  return numericid_;
}
inline uint32_t PointLane::numericid() const {
  // @@protoc_insertion_point(field_get:prescan.perception.PointLane.numericID)
  return _internal_numericid();
}
inline void PointLane::_internal_set_numericid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  numericid_ = value;
}
inline void PointLane::set_numericid(uint32_t value) {
  _internal_set_numericid(value);
  // @@protoc_insertion_point(field_set:prescan.perception.PointLane.numericID)
}

// optional .prescan.common.Header header = 3;
inline bool PointLane::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool PointLane::has_header() const {
  return _internal_has_header();
}
inline const ::prescan::common::Header& PointLane::_internal_header() const {
  const ::prescan::common::Header* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::prescan::common::Header&>(
      ::prescan::common::_Header_default_instance_);
}
inline const ::prescan::common::Header& PointLane::header() const {
  // @@protoc_insertion_point(field_get:prescan.perception.PointLane.header)
  return _internal_header();
}
inline void PointLane::unsafe_arena_set_allocated_header(
    ::prescan::common::Header* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:prescan.perception.PointLane.header)
}
inline ::prescan::common::Header* PointLane::release_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::prescan::common::Header* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::prescan::common::Header* PointLane::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:prescan.perception.PointLane.header)
  _has_bits_[0] &= ~0x00000001u;
  ::prescan::common::Header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::prescan::common::Header* PointLane::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::prescan::common::Header>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::prescan::common::Header* PointLane::mutable_header() {
  ::prescan::common::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:prescan.perception.PointLane.header)
  return _msg;
}
inline void PointLane::set_allocated_header(::prescan::common::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:prescan.perception.PointLane.header)
}

// -------------------------------------------------------------------

// PointLanes

// repeated .prescan.perception.PointLane lane = 1;
inline int PointLanes::_internal_lane_size() const {
  return lane_.size();
}
inline int PointLanes::lane_size() const {
  return _internal_lane_size();
}
inline void PointLanes::clear_lane() {
  lane_.Clear();
}
inline ::prescan::perception::PointLane* PointLanes::mutable_lane(int index) {
  // @@protoc_insertion_point(field_mutable:prescan.perception.PointLanes.lane)
  return lane_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::prescan::perception::PointLane >*
PointLanes::mutable_lane() {
  // @@protoc_insertion_point(field_mutable_list:prescan.perception.PointLanes.lane)
  return &lane_;
}
inline const ::prescan::perception::PointLane& PointLanes::_internal_lane(int index) const {
  return lane_.Get(index);
}
inline const ::prescan::perception::PointLane& PointLanes::lane(int index) const {
  // @@protoc_insertion_point(field_get:prescan.perception.PointLanes.lane)
  return _internal_lane(index);
}
inline ::prescan::perception::PointLane* PointLanes::_internal_add_lane() {
  return lane_.Add();
}
inline ::prescan::perception::PointLane* PointLanes::add_lane() {
  ::prescan::perception::PointLane* _add = _internal_add_lane();
  // @@protoc_insertion_point(field_add:prescan.perception.PointLanes.lane)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::prescan::perception::PointLane >&
PointLanes::lane() const {
  // @@protoc_insertion_point(field_list:prescan.perception.PointLanes.lane)
  return lane_;
}

// optional .prescan.common.Header header = 2;
inline bool PointLanes::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool PointLanes::has_header() const {
  return _internal_has_header();
}
inline const ::prescan::common::Header& PointLanes::_internal_header() const {
  const ::prescan::common::Header* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::prescan::common::Header&>(
      ::prescan::common::_Header_default_instance_);
}
inline const ::prescan::common::Header& PointLanes::header() const {
  // @@protoc_insertion_point(field_get:prescan.perception.PointLanes.header)
  return _internal_header();
}
inline void PointLanes::unsafe_arena_set_allocated_header(
    ::prescan::common::Header* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:prescan.perception.PointLanes.header)
}
inline ::prescan::common::Header* PointLanes::release_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::prescan::common::Header* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::prescan::common::Header* PointLanes::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:prescan.perception.PointLanes.header)
  _has_bits_[0] &= ~0x00000001u;
  ::prescan::common::Header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::prescan::common::Header* PointLanes::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::prescan::common::Header>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::prescan::common::Header* PointLanes::mutable_header() {
  ::prescan::common::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:prescan.perception.PointLanes.header)
  return _msg;
}
inline void PointLanes::set_allocated_header(::prescan::common::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:prescan.perception.PointLanes.header)
}

// -------------------------------------------------------------------

// PolyNomial

// optional double N0 = 1;
inline bool PolyNomial::_internal_has_n0() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PolyNomial::has_n0() const {
  return _internal_has_n0();
}
inline void PolyNomial::clear_n0() {
  n0_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double PolyNomial::_internal_n0() const {
  return n0_;
}
inline double PolyNomial::n0() const {
  // @@protoc_insertion_point(field_get:prescan.perception.PolyNomial.N0)
  return _internal_n0();
}
inline void PolyNomial::_internal_set_n0(double value) {
  _has_bits_[0] |= 0x00000001u;
  n0_ = value;
}
inline void PolyNomial::set_n0(double value) {
  _internal_set_n0(value);
  // @@protoc_insertion_point(field_set:prescan.perception.PolyNomial.N0)
}

// optional double N1 = 2;
inline bool PolyNomial::_internal_has_n1() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PolyNomial::has_n1() const {
  return _internal_has_n1();
}
inline void PolyNomial::clear_n1() {
  n1_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double PolyNomial::_internal_n1() const {
  return n1_;
}
inline double PolyNomial::n1() const {
  // @@protoc_insertion_point(field_get:prescan.perception.PolyNomial.N1)
  return _internal_n1();
}
inline void PolyNomial::_internal_set_n1(double value) {
  _has_bits_[0] |= 0x00000002u;
  n1_ = value;
}
inline void PolyNomial::set_n1(double value) {
  _internal_set_n1(value);
  // @@protoc_insertion_point(field_set:prescan.perception.PolyNomial.N1)
}

// optional double N2 = 3;
inline bool PolyNomial::_internal_has_n2() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PolyNomial::has_n2() const {
  return _internal_has_n2();
}
inline void PolyNomial::clear_n2() {
  n2_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double PolyNomial::_internal_n2() const {
  return n2_;
}
inline double PolyNomial::n2() const {
  // @@protoc_insertion_point(field_get:prescan.perception.PolyNomial.N2)
  return _internal_n2();
}
inline void PolyNomial::_internal_set_n2(double value) {
  _has_bits_[0] |= 0x00000004u;
  n2_ = value;
}
inline void PolyNomial::set_n2(double value) {
  _internal_set_n2(value);
  // @@protoc_insertion_point(field_set:prescan.perception.PolyNomial.N2)
}

// optional double N3 = 4;
inline bool PolyNomial::_internal_has_n3() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PolyNomial::has_n3() const {
  return _internal_has_n3();
}
inline void PolyNomial::clear_n3() {
  n3_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double PolyNomial::_internal_n3() const {
  return n3_;
}
inline double PolyNomial::n3() const {
  // @@protoc_insertion_point(field_get:prescan.perception.PolyNomial.N3)
  return _internal_n3();
}
inline void PolyNomial::_internal_set_n3(double value) {
  _has_bits_[0] |= 0x00000008u;
  n3_ = value;
}
inline void PolyNomial::set_n3(double value) {
  _internal_set_n3(value);
  // @@protoc_insertion_point(field_set:prescan.perception.PolyNomial.N3)
}

// -------------------------------------------------------------------

// PolyLane

// optional .prescan.perception.PolyLane.Type type = 1;
inline bool PolyLane::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PolyLane::has_type() const {
  return _internal_has_type();
}
inline void PolyLane::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::prescan::perception::PolyLane_Type PolyLane::_internal_type() const {
  return static_cast< ::prescan::perception::PolyLane_Type >(type_);
}
inline ::prescan::perception::PolyLane_Type PolyLane::type() const {
  // @@protoc_insertion_point(field_get:prescan.perception.PolyLane.type)
  return _internal_type();
}
inline void PolyLane::_internal_set_type(::prescan::perception::PolyLane_Type value) {
  assert(::prescan::perception::PolyLane_Type_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  type_ = value;
}
inline void PolyLane::set_type(::prescan::perception::PolyLane_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:prescan.perception.PolyLane.type)
}

// optional double quality = 2;
inline bool PolyLane::_internal_has_quality() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PolyLane::has_quality() const {
  return _internal_has_quality();
}
inline void PolyLane::clear_quality() {
  quality_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double PolyLane::_internal_quality() const {
  return quality_;
}
inline double PolyLane::quality() const {
  // @@protoc_insertion_point(field_get:prescan.perception.PolyLane.quality)
  return _internal_quality();
}
inline void PolyLane::_internal_set_quality(double value) {
  _has_bits_[0] |= 0x00000010u;
  quality_ = value;
}
inline void PolyLane::set_quality(double value) {
  _internal_set_quality(value);
  // @@protoc_insertion_point(field_set:prescan.perception.PolyLane.quality)
}

// optional int32 model_degree = 3;
inline bool PolyLane::_internal_has_model_degree() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PolyLane::has_model_degree() const {
  return _internal_has_model_degree();
}
inline void PolyLane::clear_model_degree() {
  model_degree_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline int32_t PolyLane::_internal_model_degree() const {
  return model_degree_;
}
inline int32_t PolyLane::model_degree() const {
  // @@protoc_insertion_point(field_get:prescan.perception.PolyLane.model_degree)
  return _internal_model_degree();
}
inline void PolyLane::_internal_set_model_degree(int32_t value) {
  _has_bits_[0] |= 0x00000040u;
  model_degree_ = value;
}
inline void PolyLane::set_model_degree(int32_t value) {
  _internal_set_model_degree(value);
  // @@protoc_insertion_point(field_set:prescan.perception.PolyLane.model_degree)
}

// optional .prescan.perception.PolyNomial X = 4;
inline bool PolyLane::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || x_ != nullptr);
  return value;
}
inline bool PolyLane::has_x() const {
  return _internal_has_x();
}
inline void PolyLane::clear_x() {
  if (x_ != nullptr) x_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::prescan::perception::PolyNomial& PolyLane::_internal_x() const {
  const ::prescan::perception::PolyNomial* p = x_;
  return p != nullptr ? *p : reinterpret_cast<const ::prescan::perception::PolyNomial&>(
      ::prescan::perception::_PolyNomial_default_instance_);
}
inline const ::prescan::perception::PolyNomial& PolyLane::x() const {
  // @@protoc_insertion_point(field_get:prescan.perception.PolyLane.X)
  return _internal_x();
}
inline void PolyLane::unsafe_arena_set_allocated_x(
    ::prescan::perception::PolyNomial* x) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(x_);
  }
  x_ = x;
  if (x) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:prescan.perception.PolyLane.X)
}
inline ::prescan::perception::PolyNomial* PolyLane::release_x() {
  _has_bits_[0] &= ~0x00000001u;
  ::prescan::perception::PolyNomial* temp = x_;
  x_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::prescan::perception::PolyNomial* PolyLane::unsafe_arena_release_x() {
  // @@protoc_insertion_point(field_release:prescan.perception.PolyLane.X)
  _has_bits_[0] &= ~0x00000001u;
  ::prescan::perception::PolyNomial* temp = x_;
  x_ = nullptr;
  return temp;
}
inline ::prescan::perception::PolyNomial* PolyLane::_internal_mutable_x() {
  _has_bits_[0] |= 0x00000001u;
  if (x_ == nullptr) {
    auto* p = CreateMaybeMessage<::prescan::perception::PolyNomial>(GetArenaForAllocation());
    x_ = p;
  }
  return x_;
}
inline ::prescan::perception::PolyNomial* PolyLane::mutable_x() {
  ::prescan::perception::PolyNomial* _msg = _internal_mutable_x();
  // @@protoc_insertion_point(field_mutable:prescan.perception.PolyLane.X)
  return _msg;
}
inline void PolyLane::set_allocated_x(::prescan::perception::PolyNomial* x) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete x_;
  }
  if (x) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::prescan::perception::PolyNomial>::GetOwningArena(x);
    if (message_arena != submessage_arena) {
      x = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, x, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  x_ = x;
  // @@protoc_insertion_point(field_set_allocated:prescan.perception.PolyLane.X)
}

// optional .prescan.perception.PolyNomial Y = 5;
inline bool PolyLane::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || y_ != nullptr);
  return value;
}
inline bool PolyLane::has_y() const {
  return _internal_has_y();
}
inline void PolyLane::clear_y() {
  if (y_ != nullptr) y_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::prescan::perception::PolyNomial& PolyLane::_internal_y() const {
  const ::prescan::perception::PolyNomial* p = y_;
  return p != nullptr ? *p : reinterpret_cast<const ::prescan::perception::PolyNomial&>(
      ::prescan::perception::_PolyNomial_default_instance_);
}
inline const ::prescan::perception::PolyNomial& PolyLane::y() const {
  // @@protoc_insertion_point(field_get:prescan.perception.PolyLane.Y)
  return _internal_y();
}
inline void PolyLane::unsafe_arena_set_allocated_y(
    ::prescan::perception::PolyNomial* y) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(y_);
  }
  y_ = y;
  if (y) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:prescan.perception.PolyLane.Y)
}
inline ::prescan::perception::PolyNomial* PolyLane::release_y() {
  _has_bits_[0] &= ~0x00000002u;
  ::prescan::perception::PolyNomial* temp = y_;
  y_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::prescan::perception::PolyNomial* PolyLane::unsafe_arena_release_y() {
  // @@protoc_insertion_point(field_release:prescan.perception.PolyLane.Y)
  _has_bits_[0] &= ~0x00000002u;
  ::prescan::perception::PolyNomial* temp = y_;
  y_ = nullptr;
  return temp;
}
inline ::prescan::perception::PolyNomial* PolyLane::_internal_mutable_y() {
  _has_bits_[0] |= 0x00000002u;
  if (y_ == nullptr) {
    auto* p = CreateMaybeMessage<::prescan::perception::PolyNomial>(GetArenaForAllocation());
    y_ = p;
  }
  return y_;
}
inline ::prescan::perception::PolyNomial* PolyLane::mutable_y() {
  ::prescan::perception::PolyNomial* _msg = _internal_mutable_y();
  // @@protoc_insertion_point(field_mutable:prescan.perception.PolyLane.Y)
  return _msg;
}
inline void PolyLane::set_allocated_y(::prescan::perception::PolyNomial* y) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete y_;
  }
  if (y) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::prescan::perception::PolyNomial>::GetOwningArena(y);
    if (message_arena != submessage_arena) {
      y = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, y, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  y_ = y;
  // @@protoc_insertion_point(field_set_allocated:prescan.perception.PolyLane.Y)
}

// optional .prescan.perception.PolyNomial Z = 6;
inline bool PolyLane::_internal_has_z() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || z_ != nullptr);
  return value;
}
inline bool PolyLane::has_z() const {
  return _internal_has_z();
}
inline void PolyLane::clear_z() {
  if (z_ != nullptr) z_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::prescan::perception::PolyNomial& PolyLane::_internal_z() const {
  const ::prescan::perception::PolyNomial* p = z_;
  return p != nullptr ? *p : reinterpret_cast<const ::prescan::perception::PolyNomial&>(
      ::prescan::perception::_PolyNomial_default_instance_);
}
inline const ::prescan::perception::PolyNomial& PolyLane::z() const {
  // @@protoc_insertion_point(field_get:prescan.perception.PolyLane.Z)
  return _internal_z();
}
inline void PolyLane::unsafe_arena_set_allocated_z(
    ::prescan::perception::PolyNomial* z) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(z_);
  }
  z_ = z;
  if (z) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:prescan.perception.PolyLane.Z)
}
inline ::prescan::perception::PolyNomial* PolyLane::release_z() {
  _has_bits_[0] &= ~0x00000004u;
  ::prescan::perception::PolyNomial* temp = z_;
  z_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::prescan::perception::PolyNomial* PolyLane::unsafe_arena_release_z() {
  // @@protoc_insertion_point(field_release:prescan.perception.PolyLane.Z)
  _has_bits_[0] &= ~0x00000004u;
  ::prescan::perception::PolyNomial* temp = z_;
  z_ = nullptr;
  return temp;
}
inline ::prescan::perception::PolyNomial* PolyLane::_internal_mutable_z() {
  _has_bits_[0] |= 0x00000004u;
  if (z_ == nullptr) {
    auto* p = CreateMaybeMessage<::prescan::perception::PolyNomial>(GetArenaForAllocation());
    z_ = p;
  }
  return z_;
}
inline ::prescan::perception::PolyNomial* PolyLane::mutable_z() {
  ::prescan::perception::PolyNomial* _msg = _internal_mutable_z();
  // @@protoc_insertion_point(field_mutable:prescan.perception.PolyLane.Z)
  return _msg;
}
inline void PolyLane::set_allocated_z(::prescan::perception::PolyNomial* z) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete z_;
  }
  if (z) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::prescan::perception::PolyNomial>::GetOwningArena(z);
    if (message_arena != submessage_arena) {
      z = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, z, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  z_ = z;
  // @@protoc_insertion_point(field_set_allocated:prescan.perception.PolyLane.Z)
}

// optional double length = 8;
inline bool PolyLane::_internal_has_length() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool PolyLane::has_length() const {
  return _internal_has_length();
}
inline void PolyLane::clear_length() {
  length_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline double PolyLane::_internal_length() const {
  return length_;
}
inline double PolyLane::length() const {
  // @@protoc_insertion_point(field_get:prescan.perception.PolyLane.length)
  return _internal_length();
}
inline void PolyLane::_internal_set_length(double value) {
  _has_bits_[0] |= 0x00000080u;
  length_ = value;
}
inline void PolyLane::set_length(double value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:prescan.perception.PolyLane.length)
}

// optional uint32 groupID = 9;
inline bool PolyLane::_internal_has_groupid() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool PolyLane::has_groupid() const {
  return _internal_has_groupid();
}
inline void PolyLane::clear_groupid() {
  groupid_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline uint32_t PolyLane::_internal_groupid() const {
  return groupid_;
}
inline uint32_t PolyLane::groupid() const {
  // @@protoc_insertion_point(field_get:prescan.perception.PolyLane.groupID)
  return _internal_groupid();
}
inline void PolyLane::_internal_set_groupid(uint32_t value) {
  _has_bits_[0] |= 0x00000100u;
  groupid_ = value;
}
inline void PolyLane::set_groupid(uint32_t value) {
  _internal_set_groupid(value);
  // @@protoc_insertion_point(field_set:prescan.perception.PolyLane.groupID)
}

// optional uint32 lane_label = 10;
inline bool PolyLane::_internal_has_lane_label() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool PolyLane::has_lane_label() const {
  return _internal_has_lane_label();
}
inline void PolyLane::clear_lane_label() {
  lane_label_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline uint32_t PolyLane::_internal_lane_label() const {
  return lane_label_;
}
inline uint32_t PolyLane::lane_label() const {
  // @@protoc_insertion_point(field_get:prescan.perception.PolyLane.lane_label)
  return _internal_lane_label();
}
inline void PolyLane::_internal_set_lane_label(uint32_t value) {
  _has_bits_[0] |= 0x00000200u;
  lane_label_ = value;
}
inline void PolyLane::set_lane_label(uint32_t value) {
  _internal_set_lane_label(value);
  // @@protoc_insertion_point(field_set:prescan.perception.PolyLane.lane_label)
}

// optional uint32 numericID = 11;
inline bool PolyLane::_internal_has_numericid() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool PolyLane::has_numericid() const {
  return _internal_has_numericid();
}
inline void PolyLane::clear_numericid() {
  numericid_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline uint32_t PolyLane::_internal_numericid() const {
  return numericid_;
}
inline uint32_t PolyLane::numericid() const {
  // @@protoc_insertion_point(field_get:prescan.perception.PolyLane.numericID)
  return _internal_numericid();
}
inline void PolyLane::_internal_set_numericid(uint32_t value) {
  _has_bits_[0] |= 0x00000400u;
  numericid_ = value;
}
inline void PolyLane::set_numericid(uint32_t value) {
  _internal_set_numericid(value);
  // @@protoc_insertion_point(field_set:prescan.perception.PolyLane.numericID)
}

// optional .prescan.common.Header header = 12;
inline bool PolyLane::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool PolyLane::has_header() const {
  return _internal_has_header();
}
inline const ::prescan::common::Header& PolyLane::_internal_header() const {
  const ::prescan::common::Header* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::prescan::common::Header&>(
      ::prescan::common::_Header_default_instance_);
}
inline const ::prescan::common::Header& PolyLane::header() const {
  // @@protoc_insertion_point(field_get:prescan.perception.PolyLane.header)
  return _internal_header();
}
inline void PolyLane::unsafe_arena_set_allocated_header(
    ::prescan::common::Header* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:prescan.perception.PolyLane.header)
}
inline ::prescan::common::Header* PolyLane::release_header() {
  _has_bits_[0] &= ~0x00000008u;
  ::prescan::common::Header* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::prescan::common::Header* PolyLane::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:prescan.perception.PolyLane.header)
  _has_bits_[0] &= ~0x00000008u;
  ::prescan::common::Header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::prescan::common::Header* PolyLane::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000008u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::prescan::common::Header>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::prescan::common::Header* PolyLane::mutable_header() {
  ::prescan::common::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:prescan.perception.PolyLane.header)
  return _msg;
}
inline void PolyLane::set_allocated_header(::prescan::common::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:prescan.perception.PolyLane.header)
}

// -------------------------------------------------------------------

// PolyLanes

// repeated .prescan.perception.PolyLane lane = 1;
inline int PolyLanes::_internal_lane_size() const {
  return lane_.size();
}
inline int PolyLanes::lane_size() const {
  return _internal_lane_size();
}
inline void PolyLanes::clear_lane() {
  lane_.Clear();
}
inline ::prescan::perception::PolyLane* PolyLanes::mutable_lane(int index) {
  // @@protoc_insertion_point(field_mutable:prescan.perception.PolyLanes.lane)
  return lane_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::prescan::perception::PolyLane >*
PolyLanes::mutable_lane() {
  // @@protoc_insertion_point(field_mutable_list:prescan.perception.PolyLanes.lane)
  return &lane_;
}
inline const ::prescan::perception::PolyLane& PolyLanes::_internal_lane(int index) const {
  return lane_.Get(index);
}
inline const ::prescan::perception::PolyLane& PolyLanes::lane(int index) const {
  // @@protoc_insertion_point(field_get:prescan.perception.PolyLanes.lane)
  return _internal_lane(index);
}
inline ::prescan::perception::PolyLane* PolyLanes::_internal_add_lane() {
  return lane_.Add();
}
inline ::prescan::perception::PolyLane* PolyLanes::add_lane() {
  ::prescan::perception::PolyLane* _add = _internal_add_lane();
  // @@protoc_insertion_point(field_add:prescan.perception.PolyLanes.lane)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::prescan::perception::PolyLane >&
PolyLanes::lane() const {
  // @@protoc_insertion_point(field_list:prescan.perception.PolyLanes.lane)
  return lane_;
}

// optional .prescan.common.Header header = 2;
inline bool PolyLanes::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool PolyLanes::has_header() const {
  return _internal_has_header();
}
inline const ::prescan::common::Header& PolyLanes::_internal_header() const {
  const ::prescan::common::Header* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::prescan::common::Header&>(
      ::prescan::common::_Header_default_instance_);
}
inline const ::prescan::common::Header& PolyLanes::header() const {
  // @@protoc_insertion_point(field_get:prescan.perception.PolyLanes.header)
  return _internal_header();
}
inline void PolyLanes::unsafe_arena_set_allocated_header(
    ::prescan::common::Header* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:prescan.perception.PolyLanes.header)
}
inline ::prescan::common::Header* PolyLanes::release_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::prescan::common::Header* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::prescan::common::Header* PolyLanes::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:prescan.perception.PolyLanes.header)
  _has_bits_[0] &= ~0x00000001u;
  ::prescan::common::Header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::prescan::common::Header* PolyLanes::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::prescan::common::Header>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::prescan::common::Header* PolyLanes::mutable_header() {
  ::prescan::common::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:prescan.perception.PolyLanes.header)
  return _msg;
}
inline void PolyLanes::set_allocated_header(::prescan::common::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:prescan.perception.PolyLanes.header)
}

// -------------------------------------------------------------------

// Obstacles

// repeated .prescan.perception.Obstacle perception_obstacle = 1;
inline int Obstacles::_internal_perception_obstacle_size() const {
  return perception_obstacle_.size();
}
inline int Obstacles::perception_obstacle_size() const {
  return _internal_perception_obstacle_size();
}
inline void Obstacles::clear_perception_obstacle() {
  perception_obstacle_.Clear();
}
inline ::prescan::perception::Obstacle* Obstacles::mutable_perception_obstacle(int index) {
  // @@protoc_insertion_point(field_mutable:prescan.perception.Obstacles.perception_obstacle)
  return perception_obstacle_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::prescan::perception::Obstacle >*
Obstacles::mutable_perception_obstacle() {
  // @@protoc_insertion_point(field_mutable_list:prescan.perception.Obstacles.perception_obstacle)
  return &perception_obstacle_;
}
inline const ::prescan::perception::Obstacle& Obstacles::_internal_perception_obstacle(int index) const {
  return perception_obstacle_.Get(index);
}
inline const ::prescan::perception::Obstacle& Obstacles::perception_obstacle(int index) const {
  // @@protoc_insertion_point(field_get:prescan.perception.Obstacles.perception_obstacle)
  return _internal_perception_obstacle(index);
}
inline ::prescan::perception::Obstacle* Obstacles::_internal_add_perception_obstacle() {
  return perception_obstacle_.Add();
}
inline ::prescan::perception::Obstacle* Obstacles::add_perception_obstacle() {
  ::prescan::perception::Obstacle* _add = _internal_add_perception_obstacle();
  // @@protoc_insertion_point(field_add:prescan.perception.Obstacles.perception_obstacle)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::prescan::perception::Obstacle >&
Obstacles::perception_obstacle() const {
  // @@protoc_insertion_point(field_list:prescan.perception.Obstacles.perception_obstacle)
  return perception_obstacle_;
}

// optional .prescan.common.Header header = 2;
inline bool Obstacles::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool Obstacles::has_header() const {
  return _internal_has_header();
}
inline const ::prescan::common::Header& Obstacles::_internal_header() const {
  const ::prescan::common::Header* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::prescan::common::Header&>(
      ::prescan::common::_Header_default_instance_);
}
inline const ::prescan::common::Header& Obstacles::header() const {
  // @@protoc_insertion_point(field_get:prescan.perception.Obstacles.header)
  return _internal_header();
}
inline void Obstacles::unsafe_arena_set_allocated_header(
    ::prescan::common::Header* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:prescan.perception.Obstacles.header)
}
inline ::prescan::common::Header* Obstacles::release_header() {
  _has_bits_[0] &= ~0x00000001u;
  ::prescan::common::Header* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::prescan::common::Header* Obstacles::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:prescan.perception.Obstacles.header)
  _has_bits_[0] &= ~0x00000001u;
  ::prescan::common::Header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::prescan::common::Header* Obstacles::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000001u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::prescan::common::Header>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::prescan::common::Header* Obstacles::mutable_header() {
  ::prescan::common::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:prescan.perception.Obstacles.header)
  return _msg;
}
inline void Obstacles::set_allocated_header(::prescan::common::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:prescan.perception.Obstacles.header)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace perception
}  // namespace prescan

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::prescan::perception::Obstacle_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::prescan::perception::Obstacle_Type>() {
  return ::prescan::perception::Obstacle_Type_descriptor();
}
template <> struct is_proto_enum< ::prescan::perception::Obstacle_SubType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::prescan::perception::Obstacle_SubType>() {
  return ::prescan::perception::Obstacle_SubType_descriptor();
}
template <> struct is_proto_enum< ::prescan::perception::PolyLane_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::prescan::perception::PolyLane_Type>() {
  return ::prescan::perception::PolyLane_Type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bridge_5fmsgs_2fperception_5fmsgs_2fobstacle_2eproto
